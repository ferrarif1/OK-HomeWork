![image-20220307201002120](https://i.imgur.com/jQeW7pb.png)

逻辑产生错误,这样并不能判断到设置的points值不能大于100,严格来说应为0-100.这段代码产生的问题是设置学生分数时,是先查询学生的分数再进行录入或个性,uint默认值为0,导致第一次录入无论是什么分数都能录入成功,而大于100后想修改将永远修改不了.

---

<img src="https://i.imgur.com/NCGW8hj.png" alt="image-20220307201014109" style="zoom:50%;" />

这么写有些冗余,因为uint的默认值为0,所以仅需要累加就足够,例如:

```solidity
receive() external payable {
  emit logdata(msg.value);
  balances[msg.sender] += msg.value;
  total += msg.value;
}
```

---

![image-20220307190811520](https://i.imgur.com/7GFsEVx.png)

作者本意可能是希望提取全部时清空数组内所有数据,但用remove方法会产生问题是循环下去后并不能达到效果,例如[a,b,c,d,e],当循环下标为0时,数组将改变为[e,b,c,d],当循环下标为1时,数组将改变为[e,d,c],以此类推

如按我的想法我会更改为:

```solidity
function withdrawAll() public onlyOwner{
	payable(msg.sender).transfer(address(this).balance);
	delete addr;
}
```

---

![image-20220307202833012](https://i.imgur.com/BYRE273.png)

此份代码我的理解为部署Teacher合约,当部署Teacher合约时会new出Score合约,并且初始化Score合约中的构造函数时,传入的是EOA账号,令其初始化teacherAddr = EOA账号,此时当设置分数触发onlyTeacher时,传入的msg.sender是合约账号,所以是失败的,此代码逻辑应使用tx.origin解决,或手动设置score合约中teacherAddr值为Teacher合约地址

---

![image-20220307203535111](https://i.imgur.com/8s6duZM.png)

以常理需求来说,Teacher合约并不能所有用户都能调用,所以需要加上权限控制

---

![image-20220307204414737](https://i.imgur.com/Leg2UsB.png)

并没有起到真正的权限控制,onlyTeacher随调用者指定teacher地址都能执行到setScore

---

![image-20220307205623960](https://i.imgur.com/bf9ol2h.png)

代码没问题,可精简receive部分逻辑,但不理解是receive和fallback同时存在的作用,正常只需存在一个仅可.希望纠正我的不理解

---

![image-20220307210618145](https://i.imgur.com/vHCY7gK.png)

Score合约部署时将EOA设为teacher,当Teacher合约调用Score时是无法msg.sender == teacher的